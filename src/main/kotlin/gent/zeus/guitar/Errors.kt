package gent.zeus.guitar

/**
 * error generated by the application that can be returned to the user
 *
 * @param message message of the error
 * @param remoteError error from the remote that caused this error
 */
abstract class DataFetchError(val message: String, val remoteError: String?, val httpStatusCode: Int) {

    override fun toString(): String {
        return this::class.simpleName ?: "anonymous class"
    }

    fun debugString(): String =
        "${toString()}(message=$message, remoteError=$remoteError, httpStatusCode=$httpStatusCode)"
}

/**
 * error caused by user wrongdoing
 */
open class UserError(message: String, remoteError: String?, httpStatusCode: Int = 400) :
    DataFetchError(message, remoteError, httpStatusCode)

/**
 * error caused by server mishaps
 */
open class ServerError(message: String, remoteError: String?, httpStatusCode: Int = 500) :
    DataFetchError(message, remoteError, httpStatusCode)

class MultiError(errors: List<DataFetchError>) : DataFetchError(
    message = errors.joinToString(
        ", ",
        if (errors.size > 1) "multiple errors were encountered: " else "",
    ) { "${it.message} (${it.httpStatusCode})" },
    remoteError = errors.joinToString(
        "; ",
    ) { "${it.remoteError}" },
    httpStatusCode = when {
        errors.any { it.httpStatusCode == 404 } -> 404
        errors.any { it.httpStatusCode in 400..499 } -> 400
        else -> 500
    }
)

/**
 * success or error when handling musical data
 */
sealed class DataResult<out T> {
    data class Ok<T>(val value: T) : DataResult<T>()
    data class Error<E : DataFetchError>(val error: E) : DataResult<Nothing>()
}

/**
 * tries to execute the code block. if the code throws an exception, it makes an error log statement
 * and re-throws the exception
 *
 * @param messageOnFail message to put in log statement (will append ` (stacktrace below)`)
 * @param block code block to try executing
 */
inline fun logExceptionFail(messageOnFail: String, block: () -> Unit) {
    try {
        block()
    } catch (e: Exception) {
        logger.error("$messageOnFail: ${e.message} (stacktrace below)")
        throw e
    }
}

inline fun <R> logExceptionWarn(messageOnFail: String, block: () -> R) =
    try {
        block()
    } catch (e: Exception) {
        logger.warn("$messageOnFail: ${e.message} (stacktrace below)")
        e.printStackTrace()
        null
    }

